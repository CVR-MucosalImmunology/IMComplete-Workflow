import os
import cv2
import numpy as np
import pandas as pd
import tifffile
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display, clear_output
from matplotlib.widgets import RectangleSelector

def RegisterImages(rootdir, 
                   projdir, 
                   static_dir, 
                   static_channel, 
                   static_suffix, 
                   moving_dir, 
                   moving_channel = "DAPI", 
                   moving_suffix,
                   out_dir = "analysis/2b_registered", 
                   out_dir_suffix = "_reg",
                   static_panel_dir = "panel.csv", 
                   moving_panel_dir = "panel_IF.csv",
                   combine=False):
    """
    Creates an interactive UI to register a static image (e.g. IMC DNA) with a moving image (e.g. IF DAPI).
    If combine==True, then when saving, the transform is applied to all slices of the moving image stack,
    and the resulting transformed moving stack is appended to the full static image stack.
    A combined panel CSV is also generated by concatenating the raw static and moving panel CSVs.
    """
    # --- Helper functions for contrast adjustment and tinting ---
    def adjust_contrast_range(image, contrast_range):
        image_norm = image.astype(np.float32) / 255.0
        low, high = contrast_range
        if high - low < 1e-6:
            return image.copy()
        stretched = np.clip((image_norm - low) / (high - low), 0, 1)
        return (stretched * 255).astype(np.uint8)

    def tint_blue(image):
        return np.stack([np.zeros_like(image), np.zeros_like(image), image], axis=-1)

    def tint_yellow(image):
        return np.stack([image, image, np.zeros_like(image)], axis=-1)

    # --- Load panel CSV and get channel index ---
    def load_panel(panel_csv_path, channel_name):
        panel = pd.read_csv(panel_csv_path)
        panel_full = panel[panel["Full"]==1].reset_index(drop=True)
        matches = panel_full.index[panel_full["Target"]==channel_name].tolist()
        if not matches:
            raise ValueError(f"Channel '{channel_name}' not found in panel {panel_csv_path}.")
        return panel_full, matches[0]
    
    # --- List image files and extract base names ---
    def list_images(image_dir, suffix):
        valid_ext = (".tif", ".tiff")
        files = [f for f in os.listdir(image_dir) if f.endswith(valid_ext) and f.find(suffix) != -1]
        base_names = {}
        for f in files:
            for ext in valid_ext:
                if f.endswith(suffix + ext):
                    name = f[:-len(suffix + ext)]
                    base_names[name] = f
                    break
        return base_names

    # --- Load an image stack and select the channel slice ---
    def load_channel_image(image_dir, base_name, suffix, panel_csv, channel_name):
        for ext in [".tif", ".tiff"]:
            candidate = os.path.join(image_dir, f"{base_name}{suffix}{ext}")
            if os.path.exists(candidate):
                file_path = candidate
                break
        else:
            raise FileNotFoundError(f"Image file for {base_name}{suffix} not found in {image_dir}.")
        img_stack = tifffile.imread(file_path)
        panel_full, chan_idx = load_panel(os.path.join(rootdir, projdir, panel_csv), channel_name)
        if img_stack.ndim == 3:
            if chan_idx >= img_stack.shape[0]:
                raise ValueError(f"Channel index {chan_idx} out of bounds for image stack with {img_stack.shape[0]} slices.")
            img = img_stack[chan_idx, :, :]
        else:
            img = img_stack.copy()
        if img.dtype != np.uint8:
            img = cv2.normalize(img, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
        return img

    # --- Helper function to load full image stack ---
    def load_full_stack(image_dir, base_name, suffix):
        for ext in [".tif", ".tiff"]:
            candidate = os.path.join(image_dir, f"{base_name}{suffix}{ext}")
            if os.path.exists(candidate):
                return tifffile.imread(candidate)
        raise FileNotFoundError(f"Full image stack for {base_name}{suffix} not found in {image_dir}.")

    # --- Prepare image file lists and dropdown menus ---
    static_images = list_images(os.path.join(rootdir, projdir, static_dir), static_suffix)
    moving_images = list_images(os.path.join(rootdir, projdir, moving_dir), moving_suffix)
    
    static_dropdown = widgets.Dropdown(options=sorted(static_images.keys()), description="Static:")
    moving_dropdown = widgets.Dropdown(options=sorted(moving_images.keys()), description="Moving:")

    # --- Global variables ---
    static_img_orig = None
    moving_img_orig = None
    global_overlay = None
    global_static  = None
    global_aligned = None
    global_fig = None
    global_ax_left = None
    global_ax_right = None
    ROI = {"x": 0, "y": 0, "w": 0, "h": 0}
    rect_sel = None
    saved_path = None
    # Store the computed transformation matrix and dimensions
    transformation_matrix = None
    global_dims = None
    registration_metrics = {}

    # --- Widgets for adjustable parameters ---
    static_contrast_slider = widgets.FloatRangeSlider(
        value=[0.0, 1.0], min=0.0, max=1.0, step=0.01,
        description='Static Contrast:',
        layout=widgets.Layout(width='300px')
    )
    moving_contrast_slider = widgets.FloatRangeSlider(
        value=[0.0, 1.0], min=0.0, max=1.0, step=0.01,
        description='Moving Contrast:',
        layout=widgets.Layout(width='300px')
    )
    ratio_threshold_slider = widgets.FloatSlider(value=0.92, min=0.80, max=0.98, step=0.01, description='Ratio Thresh:')
    ransac_threshold_slider  = widgets.IntSlider(value=25, min=5, max=50, step=1, description='RANSAC Thresh:')
    sift_sigma_slider        = widgets.FloatSlider(value=1.6, min=1.0, max=3.0, step=0.1, description='SIFT Sigma:')
    hist_eq_checkbox         = widgets.Checkbox(value=True, description='Histogram Equalisation')

    update_button = widgets.Button(description="Update Registration", button_style='success')
    crop_button   = widgets.Button(description="Crop", button_style='warning')
    save_button   = widgets.Button(description="Save Registered IF", button_style='info')
    output_folder_text = widgets.Text(
        value=os.path.join(rootdir, projdir, out_dir),
        description="Output Folder:",
        layout=widgets.Layout(width='400px')
    )
    
    fig_out = widgets.Output()

    # --- Load images based on dropdown selection ---
    def load_images_from_selection(change=None):
        nonlocal static_img_orig, moving_img_orig
        base_static = static_dropdown.value
        base_moving = moving_dropdown.value
        static_img_orig = load_channel_image(os.path.join(rootdir, projdir, static_dir),
                                             base_static, static_suffix,
                                             static_panel_dir, static_channel)
        moving_img_orig = load_channel_image(os.path.join(rootdir, projdir, moving_dir),
                                             base_moving, moving_suffix,
                                             moving_panel_dir, moving_channel)
    
    load_images_from_selection()
    static_dropdown.observe(load_images_from_selection, names='value')
    moving_dropdown.observe(load_images_from_selection, names='value')

    # --- Registration and display function ---
    def update_registration(b):
        nonlocal global_overlay, global_static, global_aligned, global_fig, global_ax_left, global_ax_right, rect_sel, ROI, transformation_matrix, global_dims, registration_metrics
        with fig_out:
            clear_output(wait=True)
            static_range = static_contrast_slider.value
            moving_range = moving_contrast_slider.value
            ratio_thresh    = ratio_threshold_slider.value
            ransac_thresh   = ransac_threshold_slider.value
            sift_sigma      = sift_sigma_slider.value
            use_hist_eq     = hist_eq_checkbox.value

            if use_hist_eq:
                static_img = cv2.equalizeHist(static_img_orig)
                moving_img = cv2.equalizeHist(moving_img_orig)
            else:
                static_img = static_img_orig.copy()
                moving_img = moving_img_orig.copy()
            static_img = adjust_contrast_range(static_img, static_range)
            moving_img = adjust_contrast_range(moving_img, moving_range)

            h_static, w_static = static_img.shape
            h_moving, w_moving = moving_img.shape
            global_dims = (w_static, h_static)
            if (h_moving, w_moving) != (h_static, w_static):
                scale_x = w_moving / w_static
                scale_y = h_moving / h_static
                moving_img_small = cv2.resize(moving_img, (w_static, h_static), interpolation=cv2.INTER_AREA)
            else:
                scale_x = scale_y = 1.0
                moving_img_small = moving_img.copy()

            sift = cv2.SIFT_create(nOctaveLayers=3, sigma=sift_sigma)
            kp_static, des_static = sift.detectAndCompute(static_img, None)
            kp_moving_small, des_moving_small = sift.detectAndCompute(moving_img_small, None)

            bf = cv2.BFMatcher(cv2.NORM_L2)
            matches = bf.knnMatch(des_static, des_moving_small, k=2) if (des_static is not None and des_moving_small is not None) else []
            good_matches = [m for m, n in matches if m.distance < ratio_thresh * n.distance] if matches else []

            if len(good_matches) >= 3:
                pts_static = np.float32([kp_static[m.queryIdx].pt for m in good_matches]).reshape(-1,2)
                pts_moving_small = np.float32([kp_moving_small[m.trainIdx].pt for m in good_matches]).reshape(-1,2)
                M_small, inliers = cv2.estimateAffine2D(pts_moving_small, pts_static, None, cv2.RANSAC, ransac_thresh, 2000, 0.99, 10)
                if M_small is not None:
                    M = M_small.copy()
                    M[0,0] /= scale_x
                    M[0,1] /= scale_y
                    M[1,0] /= scale_x
                    M[1,1] /= scale_y
                    transformation_matrix = M.copy()
                    rotation_rad = np.arctan2(M[1,0], M[0,0])
                    rotation_deg = np.degrees(rotation_rad)
                    scale_x_val = np.sqrt(M[0,0]**2 + M[1,0]**2)
                    scale_y_val = np.sqrt(M[0,1]**2 + M[1,1]**2)
                    translation_x = M[0,2]
                    translation_y = M[1,2]
                    registration_metrics['Rotation (deg)'] = rotation_deg
                    registration_metrics['Scale X'] = scale_x_val
                    registration_metrics['Scale Y'] = scale_y_val
                    registration_metrics['Translation X'] = translation_x
                    registration_metrics['Translation Y'] = translation_y

                    aligned_moving = cv2.warpAffine(moving_img, M, (w_static, h_static), flags=cv2.INTER_LINEAR)
                else:
                    aligned_moving = cv2.resize(moving_img, (w_static, h_static))
            else:
                aligned_moving = cv2.resize(moving_img, (w_static, h_static))

            global_aligned = aligned_moving.copy()
            blue_static   = tint_blue(static_img)
            yellow_aligned = tint_yellow(aligned_moving)
            overlay = cv2.addWeighted(blue_static, 0.5, yellow_aligned, 0.5, 0)

            global_overlay = overlay
            global_static  = static_img.copy()
            ROI["x"] = ROI["y"] = ROI["w"] = ROI["h"] = 0

            global_fig, (global_ax_left, global_ax_right) = plt.subplots(1, 2, figsize=(12,6))
            global_ax_left.imshow(static_img, cmap='gray')
            global_ax_left.set_title("Static Image — Draw ROI here")
            global_ax_left.axis('off')
            global_ax_right.imshow(overlay)
            global_ax_right.set_title("Registration Output (Overlay)")
            global_ax_right.axis('off')
            rect_sel = RectangleSelector(
                global_ax_left,
                on_select,
                useblit=False,
                interactive=True,
                button=[1],
                props=dict(facecolor='none', edgecolor='red', fill=False, alpha=1)
            )
            plt.tight_layout()
            plt.show()

    def on_select(eclick, erelease):
        x1, y1 = eclick.xdata, eclick.ydata
        x2, y2 = erelease.xdata, erelease.ydata
        x_min, x_max = sorted([int(round(x1)), int(round(x2))])
        y_min, y_max = sorted([int(round(y1)), int(round(y2))])
        ROI["x"] = x_min
        ROI["y"] = y_min
        ROI["w"] = x_max - x_min
        ROI["h"] = y_max - y_min

    def crop_callback(b):
        nonlocal global_ax_right
        if ROI["w"] <= 0 or ROI["h"] <= 0:
            with fig_out:
                print("Please draw a rectangle on the left image first.")
            return
        cropped = global_overlay[ROI["y"]:ROI["y"]+ROI["h"], ROI["x"]:ROI["x"]+ROI["w"]]
        global_ax_right.clear()
        global_ax_right.imshow(cropped)
        global_ax_right.set_title(f"Cropped Region (x={ROI['x']}, y={ROI['y']}, w={ROI['w']}, h={ROI['h']})")
        global_ax_right.axis('off')
        global_fig.canvas.draw_idle()

    def save_callback(b):
        nonlocal saved_path
        out_folder = output_folder_text.value.strip()
        if not out_folder:
            with fig_out:
                print("Please specify a valid output folder.")
            return
        if not os.path.exists(out_folder):
            os.makedirs(out_folder)
        base_static = static_dropdown.value
        filename = f"{base_static}{static_suffix}{out_dir_suffix}.tiff"
        saved_path = os.path.join(out_folder, filename)
        cv2.imwrite(saved_path, global_aligned)
        settings = {
            "Static Contrast": static_contrast_slider.value,
            "Moving Contrast": moving_contrast_slider.value,
            "Ratio Threshold": ratio_threshold_slider.value,
            "RANSAC Threshold": ransac_threshold_slider.value,
            "SIFT Sigma": sift_sigma_slider.value,
            "Histogram Equalisation": hist_eq_checkbox.value,
            "ROI": ROI
        }
        settings.update(registration_metrics)
        options_path = os.path.join(out_folder, f"{base_static}{static_suffix}{out_dir_suffix}_options.csv")
        pd.DataFrame([settings]).to_csv(options_path, index=False)
        with fig_out:
            print("Registered image saved to:", saved_path)
            print("Options saved to:", options_path)
        
        # If combine==True, perform full-stack registration and panel concatenation.
        if combine and transformation_matrix is not None:
            # Load full stacks
            static_stack = load_full_stack(os.path.join(rootdir, projdir, static_dir), base_static, static_suffix)
            moving_stack = load_full_stack(os.path.join(rootdir, projdir, moving_dir), moving_dropdown.value, moving_suffix)
            w_static, h_static = global_dims
            transformed_moving_stack = []
            for i in range(moving_stack.shape[0]):
                ch_img = moving_stack[i, :, :]
                transformed = cv2.warpAffine(ch_img, transformation_matrix, (w_static, h_static), flags=cv2.INTER_LINEAR)
                transformed_moving_stack.append(transformed)
            transformed_moving_stack = np.stack(transformed_moving_stack)
            combined_stack = np.concatenate([static_stack, transformed_moving_stack], axis=0)
            combined_filename = f"{base_static}{static_suffix}{out_dir_suffix}_combined.tiff"
            combined_path = os.path.join(out_folder, combined_filename)
            tifffile.imwrite(combined_path, combined_stack)
            # Create panel_combined by concatenating the raw CSVs
            panel_static = pd.read_csv(os.path.join(rootdir, projdir, static_panel_dir))
            panel_moving = pd.read_csv(os.path.join(rootdir, projdir, moving_panel_dir))
            panel_combined = pd.concat([panel_static, panel_moving], ignore_index=True)
            static_panel_dir_full = os.path.join(rootdir, projdir, os.path.dirname(static_panel_dir))
            panel_combined_path = os.path.join(static_panel_dir_full, "panel_combined.csv")
            panel_combined.to_csv(panel_combined_path, index=False)
            with fig_out:
                print("Combined image stack saved to:", combined_path)
                print("Combined panel saved to:", panel_combined_path)

    update_button.on_click(update_registration)
    crop_button.on_click(crop_callback)
    save_button.on_click(save_callback)

    ui = widgets.VBox([
        widgets.HBox([static_dropdown, moving_dropdown]),
        widgets.HBox([static_contrast_slider, moving_contrast_slider]),
        widgets.HBox([ratio_threshold_slider, ransac_threshold_slider, sift_sigma_slider]),
        hist_eq_checkbox,
        widgets.HBox([update_button, crop_button, save_button]),
        output_folder_text,
        fig_out
    ])
    display(ui)
